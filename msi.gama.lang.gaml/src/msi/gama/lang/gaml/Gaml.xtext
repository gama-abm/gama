grammar msi.gama.lang.gaml.Gaml hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate gaml "http://www.gama.msi/lang/gaml/Gaml"

/**------------------------------------------------------------------------
 * Entries of the grammar
-------------------------------------------------------------------------*/

Entry:
	->StandaloneModel | StandaloneExpression | StandaloneBlock | StandaloneExperiment;

/**------------------------------------------------------------------------
 * StandaloneBlock -- allows to compile inline actions at runtime
-------------------------------------------------------------------------*/

StandaloneBlock:
	'__synthetic__' block=Block;

/**------------------------------------------------------------------------
 * StandaloneExpression -- allows to compile inline expressions at runtime
-------------------------------------------------------------------------*/

StandaloneExpression:
	name=ID "<-" expr=Expression;

/**------------------------------------------------------------------------
 * StandaloneExperiment -- allows to compile experiment files
-------------------------------------------------------------------------*/

StandaloneExperiment:
	key=K_Experiment name=(Valid_ID | STRING) ('model:' importURI=STRING)? (facets+=Facet)*
	(block=Block | ';');

/**------------------------------------------------------------------------
 * StandaloneModel -- allows to compile model files
-------------------------------------------------------------------------*/

StandaloneModel:
	(pragmas+=Pragma)* 'model' name=ID (imports+=Import)* block=B_Model;

/**------------------------------------------------------------------------
 * Models' specific components: imports and pragmas
-------------------------------------------------------------------------*/

Import:
	'import' importURI=STRING ("as" name=Valid_ID)?; // must be named importURI

Pragma:
	'@' (name=ID ('[' plugins=ExpressionList? ']')?);


/**------------------------------------------------------------------------
 * Blocks. An ordered list of statements inside curly brackets. 
 * Some are specialized and accept only certain statements
 -------------------------------------------------------------------------*/
 
Block:
	{Block} '{' ((statements+=Statement)* '}');

B_Model returns Block:
	{Block} (statements+=(S_Section))*;

B_Switch returns Block:
	{Block} '{' (statements+=(S_Default | S_Match))* '}';

B_Display returns Block:
	{Block} '{' (statements+=S_DisplayLayer)* '}';

/**------------------------------------------------------------------------
 * General statements
-------------------------------------------------------------------------*/

Statement:
	(=> S_Declaration |
	((=> S_Assignment |  S_Switch | S_Break | S_Do | S_Return | S_Solve | S_If | S_Try | S_1Expr_Facets_BlockOrEnd /*| S_Other */|  S_Equations)))
	| S_Display ;

S_1Expr_Facets_BlockOrEnd returns Statement:
	key=K_1Expr_Facets_BlockOrEnd (expr=Expression) (facets+=Facet)* (block=Block | ";");
	
/**------------------------------------------------------------------------
 * Global statements
-------------------------------------------------------------------------*/

S_Section returns Statement:
	S_Global | S_Species | S_Experiment;

S_Global:
	key="global" (facets+=Facet)* (block=Block | ';');

S_Species:
	key=K_Species name=ID (facets+=Facet)* (block=Block | ';');

S_Experiment:
	key=K_Experiment name=(Valid_ID | STRING) (facets+=Facet)* (block=Block | ';');

/**------------------------------------------------------------------------
 * Special statements: do
-------------------------------------------------------------------------*/

S_Do:
	key=K_Do expr=AbstractRef (facets+=Facet)* (block=Block | ';');

/**------------------------------------------------------------------------
 * Control statements : loop, if, switch/match/default, try/catch, break, return
-------------------------------------------------------------------------*/

S_Loop:
	key="loop" (name=ID) (facets+=Facet)* block=Block;

S_If:
	key='if' expr=Expression block=Block (->'else' else=(S_If | Block))?;

S_Try:
	key='try' block=Block (->'catch' catch=Block)?;

S_Switch:
	key='switch' expr=Expression block=B_Switch;

S_Match returns Statement:
	key=("match" | "match_one" | "match_between" | "match_regex") expr=Expression block=Block;

S_Default returns Statement:
	key=K_Default block=Block;

S_Return returns Statement:
	key='return' expr=Expression ';';

S_Break returns Statement:
	key='break' ';';

//S_Other:
//    key=ID (facets+=Facet)* (block=Block | ';');

/**------------------------------------------------------------------------
 * Declaration statements: reflexes, actions, variables...
-------------------------------------------------------------------------*/

S_Declaration:
	->S_Definition | S_Species | S_Reflex | S_Action | S_Var | S_Loop;

S_Reflex:
	key=K_Reflex (name=Valid_ID)?	 ("when" ":" expr=Expression)? block=Block;

S_Definition:
	tkey=(TypeRef) name=(Valid_ID | STRING) ('(' (args=ActionArguments) ')')? (facets+=Facet)*
	(block=Block | ';');

S_Action returns S_Definition:
	{S_Action} key="action" name=Valid_ID ('(' (args=ActionArguments) ')')? (facets+=Facet)*
	(block=Block | ';');

S_Var returns S_Definition:
	{S_Var} key=K_Var name=Valid_ID (facets+=Facet)* ';';

/**------------------------------------------------------------------------
 * Assignment statements: <-, set, single equation
-------------------------------------------------------------------------*/

S_Assignment:
	S_DirectAssignment | S_Set;

S_DirectAssignment:
	(expr=Expression key=(K_Assignment) value=Expression (facets+=Facet)*) ';';

S_Set:
	key="set" expr=Expression ("value:" | "<-") value=Expression ";";

S_Equation returns S_Assignment:
	expr=(Function | VariableRef) key="=" value=Expression;

/**------------------------------------------------------------------------
 * Equation statements: equations system, solve
-------------------------------------------------------------------------*/

S_Equations:
	key=K_Equations name=Valid_ID (facets+=Facet)* ('{' (equations+=S_Equation ';')* '}' | ';');

S_Solve:
	key=K_Solve expr=EquationRef (facets+=Facet)* (block=Block | ';');

/**------------------------------------------------------------------------
 * Display statements: display & layers (species, grid, image)
-------------------------------------------------------------------------*/

S_Display:
	key="display" name=(Valid_ID | STRING) (facets+=Facet)* block=B_Display;

S_DisplayLayer returns Statement:
	=>S_SpeciesLayer | (=>S_ImageLayer | Statement);

S_SpeciesLayer:
	key=K_Species expr=Expression (facets+=Facet)* (block=B_Display | ";");

S_ImageLayer:
	key=K_ImageLayer expr=Expression (facets+=Facet)* ";";

/**------------------------------------------------------------------------
 * Keys of statements
-------------------------------------------------------------------------*/

K_Equations:
	"equation";

K_Solve:
	"solve";

K_Species:
	"species" | "grid";

K_ImageLayer:
	"image";

K_Experiment:
	"experiment";

K_1Expr_Facets_BlockOrEnd:
	K_Layer | "ask" | "release" | "capture" | "create" | "write" | "error" | "warn" | "exception" | "save" | "assert"
	| "inspect" | "browse" | "restore" | "draw" | "using" | "put" | "add" | "remove" | "parameter"
	| "status" | "highlight" | "focus_on" | "layout";

K_Layer:
	"light" | "camera" | "text" | "image_layer" | "data" | "chart" | "agents" | "graphics" | "display_population" |
	"display_grid" | "event" | "overlay" | "datalist" | "mesh";

K_Do:
	"do" | "invoke";

K_Default:
	"default";

K_Var:
	"var" | "const" | "let" | "arg";

K_Reflex:
	"init" | "reflex" | "aspect";

K_Assignment:
	"<-" | "<<" | '>' '>' | "<<+" | '>' '>-' | "+<-" | "<+" | ">-";

/**------------------------------------------------------------------------
 * Parameters and arguments
-------------------------------------------------------------------------*/

ActionArguments:
	args+=ArgumentDefinition (',' args+=ArgumentDefinition)*;

ArgumentDefinition:
	type=(TypeRef) name=Valid_ID ('<-' default=Expression)?;

/**------------------------------------------------------------------------
 * Facets
-------------------------------------------------------------------------*/

Facet:
	F_Action | F_Definition | F_Regular | F_Type | F_Var | F_Function;

F_Regular returns Facet:
	(key=FK_Regular | key='<-' | key=FK_Special) expr=Expression;

F_Definition returns Facet:
	((->key=FK_Definition) name=(Valid_ID | STRING));

F_Function returns Facet:
	key='->' (=>(expr=Expression) | ('{' expr=Expression '}'));

F_Type returns Facet:
	key=FK_Type (->(expr=TypeRef) | expr=Expression);

F_Action returns Facet:
	key=FK_Action (expr=ActionRef | block=Block);

F_Var returns Facet:
	key=FK_Var expr=VariableRef;
	
/**------------------------------------------------------------------------
 * Facet keys
-------------------------------------------------------------------------*/

//FirstFacetKey:
//	DefinitionFacetKey | TypeFacetKey | SpecialFacetKey | VarFacetKey | ActionFacetKey | ClassicFacetKey;

FK_Regular:
	(ID ':');

FK_Definition:
	"name:" | "returns:";

FK_Type:
	("as:" | "of:" | "parent:" | "species:" | "type:");

FK_Special:
	'camera:' | 'data:' | 'when' ':' | "const:" | "value:" | "topology:" | "item:" | "init:" | "message:" | "control:" |
	"layout:" | "environment:" | 'text:' | 'image:' | 'using:' | "parameter:" | "aspect:" | "light:";

FK_Action:
	"action:" | "on_change:";

FK_Var:
	"var:";

/**------------------------------------------------------------------------
 * Expressions
-------------------------------------------------------------------------*/

Expression:
	ArgumentPair | Pair;

BinaryOperator returns Expression:
	Or | And | Cast | Comparison | Addition | Multiplication | Exponentiation | Binary | Pair | Unit;

ArgumentPair:
	=> (op=(Valid_ID) '::' | op=(FK_Definition | FK_Type | FK_Special | FK_Action | FK_Var) ':'
	)? right=Pair;

Pair returns Expression:
	If
	({BinaryOperator.left=current}
	op='::'
	right=If)?;

If returns Expression:
	Or
	({If.left=current}
	op='?'
	right=Or
	(':'
	ifFalse=Or))?;

Or returns Expression:
	And
	({BinaryOperator.left=current}
	op='or'
	right=And)*;

And returns Expression:
	Cast
	({BinaryOperator.left=current}
	op='and'
	right=Cast)*;

Cast returns Expression:
	Comparison
	(({BinaryOperator.left=current}
	op='as') ((right=TypeRef) | ('(' right=TypeRef ')')))?;

Comparison returns Expression:
	Addition
	(({BinaryOperator.left=current}
	op=('!=' | '=' | '>=' | '<=' | '<' | '>'))
	right=Addition)?;

Addition returns Expression:
	Multiplication
	(({BinaryOperator.left=current} op=('+' | '-'))
	right=Multiplication)*;

Multiplication returns Expression:
	Exponentiation
	(({BinaryOperator.left=current} op=('*' | '/')) right=Exponentiation)*;

Exponentiation returns Expression:
	Binary
	(({BinaryOperator.left=current} op=('^')) right=Binary)*;

Binary returns Expression:
	Unit
	(({BinaryOperator.left=current} op=(Valid_ID)) right=Unit)*;

Unit returns Expression:
	Unary
	(({Unit.left=current} op=('°' | "#")) right=UnitRef)?;

Unary returns Expression:
	Access |
	{Unary} ((op=('°' | '#') right=UnitRef) | (op=('-' | '!' | 'my' | 'the' | 'not')
	right=Unary));

Access returns Expression:
	Primary ({Access.left=current} ((op='[' right=ExpressionList? ']') | (op="." right=(AbstractRef | StringLiteral))))*;

Primary returns Expression:
	TerminalExpression |
	AbstractRef |
	'(' ExpressionList ')' |
	'[' {Array} exprs=ExpressionList? ']' |
	'{' {Point} left=Expression op=',' right=Expression (',' z=Expression)? '}';


Function returns Expression:
	{Function} (left=ActionRef) (type=TypeInfo)? '(' right=ExpressionList? ')';

ExpressionList:
	(exprs+=Expression (',' exprs+=Expression)*) | (exprs+=Parameter (',' exprs+=Parameter)*);

Parameter returns Expression:
	{Parameter} ((builtInFacetKey=(FK_Definition | FK_Type | FK_Special | FK_Action | FK_Var))
	|
	(left=VariableRef ':')) right=Expression;

/**------------------------------------------------------------------------
*  References
-------------------------------------------------------------------------*/


AbstractRef returns Expression:
	=>Function | VariableRef;

UnitRef returns Expression:
	{UnitName} ref=[BuiltInUnitDefinition|Valid_ID];

VariableRef:
	{VariableRef} ref=[VarDefinition|Valid_ID];

TypeRef returns Expression:
	{TypeRef} (ref=[TypeDefinition|ID] parameter=TypeInfo?) | {TypeRef} ("species" parameter=TypeInfo) | {TypeRef}
	("image"); // Necessary to add "image" hardcoded here, because of the existence of the "image" layer

TypeInfo:
	('<' first=TypeRef ("," second=TypeRef)? ->'>');
	
SkillRef returns Expression:
	{SkillRef} ref=[BuiltInSkillDefinition|ID];

ActionRef returns Expression:
	{ActionRef} ref=[ActionDefinition|Valid_ID];

EquationRef returns Expression:
	{EquationRef} ref=[EquationDefinition|Valid_ID];

GamlDefinition:
	TypeDefinition | VarDefinition | BuiltInUnitDefinition | BuiltInSkillDefinition | ActionDefinition | EquationDefinition;

EquationDefinition:
	S_Equations | BuiltInEquationDefinition;

TypeDefinition:
	S_Species | BuiltInTypeDefinition;

VarDefinition:
	=>S_Declaration | (StandaloneModel | ArgumentDefinition | F_Definition | BuiltInVarDefinition | Import |
	S_Experiment);

ActionDefinition:
	S_Action | BuiltInActionDefinition | S_Definition | TypeDefinition;
	
/**------------------------------------------------------------------------
 * Built_in Definitions produced by the global scope provider
-------------------------------------------------------------------------*/

BuiltInUnitDefinition:
	'**unit*' name=ID;

BuiltInTypeDefinition:
	'**type*' name=ID;

BuiltInActionDefinition:
	'**action*' name=Valid_ID;

BuiltInSkillDefinition:
	'**skill*' name=ID;

BuiltInVarDefinition:
	'**var*' name=Valid_ID;

BuiltInEquationDefinition:
	'**equation*' name=Valid_ID;

/**------------------------------------------------------------------------
 * Identifiers
-------------------------------------------------------------------------*/

Valid_ID:
	K_Species | K_ImageLayer | K_Do | K_Reflex | K_Var | K_1Expr_Facets_BlockOrEnd | K_Equations |
	ID | K_Default | K_Experiment;

/**------------------------------------------------------------------------
 * Terminals
-------------------------------------------------------------------------*/

TerminalExpression:
	StringLiteral |
	{IntLiteral} op=INTEGER |
	{DoubleLiteral} op=DOUBLE |
	{BooleanLiteral} op=BOOLEAN |
	{ReservedLiteral} op=KEYWORD;

StringLiteral:
	op=STRING;

terminal KEYWORD:
	'each' | 'self' | 'myself' | 'nil' | 'super';

terminal INTEGER:
	'0' | ('1'..'9' ('0'..'9')*);

terminal BOOLEAN:
	'true' | 'false';
	
terminal ID:
	"2d" | "3d" | "2D" | "3D" | (('a'..'z' | 'A'..'Z' | '_' | '$') ('a'..'z' | 'A'..'Z' | '_' | '$' | '0'..'9')*);

terminal DOUBLE:
	'1'..'9' ('0'..'9')* ('.' '0'..'9'+)? (('E' | 'e') ('+' | '-')? '0'..'9'+)? | '0' ('.' '0'..'9'+)? (('E' | 'e') ('+'
	| '-')? '0'..'9'+)?;

terminal STRING:
	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | '\\') | !('\\' | '"'))* '"' | "'" ('\\' ('b' | 't' | 'n' | 'f'
	| 'r' | 'u' | "'" | '\\') | !('\\' | "'"))* "'";

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal ANY_OTHER:
	.;
